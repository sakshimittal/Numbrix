
(defun numbrix()
	
	(rules)
	(play-numbrix)
)

(defun rules()
	(princ "RULES:")
	(terpri) (princ "The objective of this game is to fill the board with sequence of consecutive numbers from 1 to n^2 for a nxn matrix.") 
	(terpri) (princ "The numbers must be placed in horizontal or vertical fashion (no diagonals).")
	(terpri) (princ "To win the game, the numbers must follow a snake-like structure throughout the board starting from 1 till the last number.")
)

(defun play-numbrix()

	(loop
		(terpri) (terpri) (princ "Choose a board:")
		(terpri) (princ "1. 3X3")
		(terpri) (princ "2. 8x8")
		(terpri) (terpri) (princ "Choice: ")
		(setq choice (read))

		(cond 	((equal choice 1) (setq brd (listcopy (setq o-brd (list '(1 - 3) 
										'(- - -) 
										'(7 - 9))))) 

					  (setq empty-brd (listcopy (setq e-brd (list '(- - -) 
										      '(- - -) 
										      '(- - -))))))		

			(T (setq brd (listcopy (setq o-brd (list '(45 44 39 38 23 22 19 18) 
			 	 				  '(46 - - - - - - 17) 
			 	 				  '(47 - - - - - - 16) 
		 	 	 				  '(48 - - - - - - 15) 
			  	 				  '(63 - - - - - - 14) 
			 	 				  '(64 - - - - - - 3) 
		    	  	 				  '(59 - - - - - - 4) 
			 	 				  '(58 57 56 55 8 7 6 5)))))

			   (setq empty-brd (listcopy (setq e-brd (list '(- - - - - - - -) 
			       	       				       '(- - - - - - - -) 
			               				       '(- - - - - - - -) 
			               				       '(- - - - - - - -) 
			               				       '(- - - - - - - -) 
			               				       '(- - - - - - - -) 
			               				       '(- - - - - - - -) 
			               				       '(- - - - - - - -)))))
		))

		(p-board brd)
		(play brd)
		(terpri) (princ "PATTERN DISPLAY:") 
		(terpri) (princ "----------------")
		(terpri) (traverse-snake-like-structure brd empty-brd)

		(loop
			(terpri) (terpri) (princ "Would you like to play the game again? (y/n) ")
			(setq ans (read))
			(when (or (equal ans 'y) (equal ans 'n)) (return T))
		)
		(when (equal ans 'n) (terpri) (princ "END OF GAME!") (return T))
	)
)

(defun listcopy(original-brd)
	(cond 	((null original-brd) nil)
		(t (cons (sublistcopy (car original-brd)) (listcopy (cdr original-brd))))
	)	
)

(defun sublistcopy (brd)
	(cond 	((null brd) nil)
		(t (cons (car brd) (sublistcopy (cdr brd))))
	)
)

(defun play(brd)
	(terpri) (terpri) (terpri) (terpri) (princ "FILL A CELL")
	(terpri) (princ "-----------")
	(terpri) (terpri) (princ "Enter row, column and number: ")
	(setq row (read))
	(setq col (read))
	(setq val (read))
	(setq w (row-column-out-of-bound-check row col brd))
	(setq x (number-out-of-bound-check val brd))
	(setq y (cond ((and w x) (over-writing-cell-check row col brd))))
	(setq z	(cond ((equal y t) (repeating-number-check val brd))))
	
	(cond 	((not (and (and (and w x) y) z)) (play brd))
		(t (set-sqr row col brd val) (p-board brd)))

	(repeat-play brd)

	(terpri)
)


(defun row-column-out-of-bound-check(row col brd)
	(setq n (list-length brd))
	(cond	((and (or (> row n) (< row 0)) (or (> col n) (< col 0))) (terpri) (princ "ERROR: Row and column values out of bound") nil)
		((or (> row n) (< row 0)) (terpri) (princ "ERROR: Row value out of bound") nil)
		((or (> col n) (< col 0)) (terpri) (princ "ERROR: Column value out of bound") nil)
		(t t)
))

(defun number-out-of-bound-check (val brd)
	(setq n (list-length brd))
	(setq n (* n n))
	(cond 	((> val n) (terpri) (princ "ERROR: Number out of bound. Cannot have a value greater than ") (princ n) nil)
		((< val 1) (terpri) (princ "ERROR: Number out of bound. Cannot have a value smaller than 1") nil)
		(t t)
))

(defun over-writing-cell-check (row col brd)
	(setq q (sqr row col brd))
	(cond	((equal q '-) t)
		(t (terpri) (princ "ERROR: Cell (") (princ row) (princ ",") (princ col) (princ ") is already filled. Cannot over-write") nil)
))

(defun repeating-number-check (val brd)
	(cond 	((null brd) t)
		((member val (car brd)) (terpri) (princ "ERROR: ") (princ val) (princ " already present in the matrix") nil) 
		(t (repeating-number-check val (cdr brd)))
))


(defun repeat-play (brd)
	(setq x (repeat brd))
	(cond   ((null x) nil)
		(t (play brd))
))

(defun repeat (x)
	(cond 	((null x) nil)
		((member '- (car x)) t)
		(t (repeat (cdr x)))
))

(defun traverse-snake-like-structure (brd empty-brd)
	(setq row (find-1-row (list-length brd) brd))
	(setq col (find-1-col brd))
	(set-sqr row col empty-brd 1)
	(p-board empty-brd)
	(go-up 1 row col brd empty-brd)
)

(defun find-1-row (n brd)
	(cond ((null brd) nil)
	((member 1 (car brd)) n)
	(t (setq n (1- n)) (find-1-row n (cdr brd)))
))

(defun find-1-col (brd)
	(cond ((null brd) nil)
	((member 1 (car brd)) (setq lst (car brd)) (find-1-col-number 0 lst))
	(t (find-1-col (cdr brd)))
))

(defun find-1-col-number (l lst)
	(cond	((null lst) nil)
		((equal 1 (car lst)) (1+ l))
		(t (find-1-col-number (1+ l) (cdr lst)))
))

(defun go-up (val row col brd empty-brd)
	(setq n (list-length brd))
	(setq max (* n n))
	(if (>= val max) (progn (terpri) (princ "HOORAY! CORRECT SOLUTION!"))
		(if (> (1+ row) n) (go-down val row col brd empty-brd) 
			  (if (not (equal (sqr (1+ row) col brd) (1+ val))) (go-down val row col brd empty-brd)
			  (progn (setq row (1+ row)) (setq val (1+ val)) (set-sqr row col empty-brd val) (terpri) (p-board empty-brd) (go-up val row col brd empty-brd))	
			)     			
		)
))

(defun go-down (val row col brd empty-brd)
	(if (< (1- row) 1) (go-right val row col brd empty-brd) 
		(if (not (equal (sqr (1- row) col brd) (1+ val))) (go-right val row col brd empty-brd) 
		(progn (setq row (1- row)) (setq val (1+ val)) (set-sqr row col empty-brd val) (terpri) (p-board empty-brd) (go-up val row col brd empty-brd))
		)
	)
)

(defun go-right (val row col brd empty-brd)
	(if (> (1+ col) n) (go-left val row col brd empty-brd) 
		(if (not (equal (sqr row (1+ col) brd) (1+ val))) (go-left val row col brd empty-brd) 
		(progn (setq col (1+ col)) (setq val (1+ val)) (set-sqr row col empty-brd val) (terpri) (p-board empty-brd) (go-up val row col brd empty-brd))
		)
	)
)

(defun go-left (val row col brd empty-brd)
	(if (< (1- col) 1) (progn (terpri) (princ "SOLUTION INCORRECT! PLEASE TRY AGAIN!"))  
		(if (not (equal (sqr row (1- col) brd) (1+ val))) (princ "Solution Incorrect! Please try again!") 
		(progn (setq col (1- col)) (setq val (1+ val)) (set-sqr row col empty-brd val) (terpri) (p-board empty-brd) (go-up val row col brd empty-brd))
		)
	)
)

(defun sqr (row col brd)
	(setq n (list-length brd))
	(nth (1- col)
		(nth (- n row) brd )))

(defun set-sqr (row col brd val)
	(setq n (list-length brd))
	(setf (nth (1- col)
		(nth (- n row) brd))
		val))

(defun p-board (brd)
	(setq n (list-length brd))
	(cond 	((<= n 3) (p-board-single-digit brd n))
		((<= n 9) (p-board-double-digit brd n))
		(T (p-board-triple-digit brd n))))

(defun p-board-single-digit (brd n)	
	(cond 	((null brd) (terpri) (princ "+") (print-plus-minus-single n))
		(T (terpri) (princ "+") (print-plus-minus-single n)
		(terpri) (p-row-single (car brd))
		(p-board-single-digit (cdr brd) n))))

(defun print-plus-minus-single (n)
	(cond 	((equal n 0) nil)
		(T (princ "-+") (print-plus-minus-single (1- n)))))

(defun p-row-single (row)
	(cond 	((null row) (princ "|"))
		(T (princ "|")
		(princ (car row))
		(p-row-single (cdr row)))))

(defun p-board-double-digit (brd n)	
	(cond 	((null brd) (terpri) (princ "+") (print-plus-minus-double n))
		(T (terpri) (princ "+") (print-plus-minus-double n)
		(terpri) (p-row-double (car brd))
		(p-board-double-digit (cdr brd) n))))

(defun print-plus-minus-double (n)
	(cond 	((equal n 0) nil)
		(T (princ "--+") (print-plus-minus-double (1- n)))))

(defun p-row-double (row)
	(cond 	((null row) (princ "|"))
		(T (princ "|")
		   (setq num (car row))
		   (princ num)
		   (setq counter 0)
		   (if (equal num '-) (princ " ") 
              	       (progn
		       (setq counter (check-number-of-digits counter num))
		       (if (= counter 1) (princ " ")) 
                       ))			
		(p-row-double (cdr row)))))

(defun p-board-triple-digit (brd n)	
	(cond 	((null brd) (terpri) (princ "+") (print-plus-minus-triple n))
		(T (terpri) (princ "+") (print-plus-minus-triple n)
		(terpri) (p-row-triple (car brd))
		(p-board-triple-digit (cdr brd) n))))

(defun print-plus-minus-triple (n)
	(cond 	((equal n 0) nil)
		(T (princ "---+") (print-plus-minus-triple (1- n)))))

(defun p-row-triple (row)
	(cond 	((null row) (princ "|"))
		(T (princ "|")
		   (setq num (car row))
		   (setq num1 num)
		   (setq counter 0)
		   (if (equal num '-) (princ " - ") 
              	   (progn
			(setq counter (check-number-of-digits counter num1))
			(if (= counter 1) (progn (princ " ") (princ num) (princ " "))
			(if (= counter 2) (progn (princ num) (princ " "))
			(princ num)))
                   ))			
		(p-row-triple (cdr row)))))

(defun check-number-of-digits(counter num)
	(if (= num 0) counter
	(progn
		(setq num (floor (/ num 10)))
        	(setq counter (1+ counter))
		(check-number-of-digits counter num))))